<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<title>Snake (Mobile Optimized)</title>
<link rel="stylesheet" href="../../assets/style.css?v=4" />
<style>
  .wrap {
    display:flex; flex-direction:column; align-items:center; gap:12px;
  }
  .topbar {
    display:flex; align-items:center; justify-content:center; gap:10px; flex-wrap:wrap;
    color: var(--muted);
  }
  .score-badge {
    display:inline-flex; align-items:center; gap:8px;
    background: var(--elev-2);
    border:1px solid rgba(0,0,0,0.1);
    padding:.45rem .7rem; border-radius: 999px; font-weight:600;
  }
  @media (prefers-color-scheme: dark){
    .score-badge { border-color: rgba(255,255,255,0.14); }
  }

  /* 캔버스: CSS 크기는 레이아웃용, 내부 픽셀은 JS에서 DPR 맞춤 */
  .board {
    width: min(92vw, 520px);
    aspect-ratio: 1 / 1;           /* 정사각형 유지 */
    background: linear-gradient(180deg,#eef3ff 0%, #e8eeff 100%);
    border-radius: 16px;
    border:1px solid rgba(0,0,0,0.15);
    touch-action: none;             /* 스와이프 조작시 페이지 스크롤 방지 */
  }
  @media (prefers-color-scheme: dark){
    .board { background: linear-gradient(180deg,#161b28 0%, #121622 100%); border-color: rgba(255,255,255,0.12); }
  }

  .controls {
    user-select:none; -webkit-user-select:none;
    display:grid; grid-template-columns: 64px 64px 64px; grid-template-rows: 64px 64px; 
    gap:10px; justify-content:center; margin-top: 4px;
  }
  .btn-pad {
    display:flex; align-items:center; justify-content:center;
    background: var(--elev-2);
    border:1px solid rgba(0,0,0,0.12);
    border-radius: 16px;
    font-size: 22px; font-weight: 800;
    width:64px; height:64px;
  }
  .btn-pad:active { transform: translateY(1px); }
  @media (prefers-color-scheme: dark){ .btn-pad { border-color: rgba(255,255,255,0.14); } }

  /* 배치:   [  ↑ ] 
              [←][↓][→]  */
  .pad-up    { grid-column: 2 / 3; grid-row: 1 / 2; }
  .pad-left  { grid-column: 1 / 2; grid-row: 2 / 3; }
  .pad-down  { grid-column: 2 / 3; grid-row: 2 / 3; }
  .pad-right { grid-column: 3 / 4; grid-row: 2 / 3; }

  .hint { text-align:center; }

  /* 캔버스 위 안내 텍스트 */
  .overlay {
    position: absolute; inset: 0; display:flex; align-items:center; justify-content:center;
    pointer-events:none; text-align:center; padding: 0 1rem;
  }
  .overlay .bubble {
    background: rgba(0,0,0,0.65);
    color:#fff; border-radius: 12px; padding:.6rem .9rem; font-size: .95rem;
  }

  /* 캔버스 컨테이너 (오버레이 포지셔닝용) */
  .board-wrap { position: relative; }
</style>
</head>
<body>
  <header class="site-header">
    <div class="container">
      <a class="brand" href="../../">✨ Playground</a>
    </div>
  </header>

  <main class="container">
    <section class="hero">
      <h1>Snake (Mobile Optimized)</h1>
      <p>Arrow keys / WASD on desktop. On mobile, tap the D-pad or swipe to change direction.</p>
    </section>

    <div class="wrap">
      <div class="topbar">
        <div class="score-badge">Score: <span id="score">0</span></div>
        <div class="score-badge">Best: <span id="best">0</span></div>
        <button class="btn" id="restart">Restart</button>
        <button class="btn" id="pause">Pause</button>
      </div>

      <div class="board-wrap">
        <canvas id="board" class="board"></canvas>
        <div id="overlay" class="overlay" hidden>
          <div class="bubble">Paused — tap any control to resume</div>
        </div>
      </div>

      <!-- 모바일 D-pad -->
      <div class="controls" aria-label="touch controls">
        <button class="btn-pad pad-up"    data-dir="up"    aria-label="Up">↑</button>
        <button class="btn-pad pad-left"  data-dir="left"  aria-label="Left">←</button>
        <button class="btn-pad pad-down"  data-dir="down"  aria-label="Down">↓</button>
        <button class="btn-pad pad-right" data-dir="right" aria-label="Right">→</button>
      </div>

      <div class="hint muted">Tip: You can also swipe on the board to turn.</div>
    </div>
  </main>

  <script>
    // ===== Canvas DPR 세팅 =====
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    function setupCanvas() {
      const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
      const cssW = Math.round(canvas.clientWidth);
      const cssH = Math.round(canvas.clientHeight);
      canvas.width = cssW * dpr;
      canvas.height = cssH * dpr;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      return { W: cssW, H: cssH };
    }

    // ===== 게임 설정(반응형 그리드) =====
    let W=360, H=360;
    ({ W, H } = setupCanvas());
    window.addEventListener('resize', () => { ({ W, H } = setupCanvas()); fitGrid(); });

    // 화면 크기에 맞춰 셀 크기/행열 계산
    let COLS, ROWS, CELL;
    function fitGrid(){
      // 모바일에서 너무 작은 셀은 피하고, 너무 큰 셀도 제한
      // 목표: 보드 한 변에 18~28칸
      const targetCells = Math.max(18, Math.min(28, Math.floor(W / 16)));
      CELL = Math.floor(Math.min(W, H) / targetCells);
      COLS = Math.floor(W / CELL);
      ROWS = Math.floor(H / CELL);
      // 중앙 정렬되도록 보드 안쪽 여백을 나중에 offset으로 사용
      offX = Math.floor((W - COLS * CELL) / 2);
      offY = Math.floor((H - ROWS * CELL) / 2);
    }

    let offX=0, offY=0;
    fitGrid();

    // ===== 게임 상태 =====
    let snake, dir, nextDir, food, score=0, best=Number(localStorage.getItem('snakeBest')||0);
    let running=true, stepMs=110, lastTick=0;

    document.getElementById('best').textContent = best;

    function reset(){
      score = 0;
      updateScore();
      dir = {x:1, y:0}; nextDir = {x:1, y:0};
      const cx = Math.floor(COLS/2), cy = Math.floor(ROWS/2);
      snake = [{x:cx-1,y:cy}, {x:cx-2,y:cy}]; // 2칸짜리 시작
      spawnFood();
      running = true;
      lastTick = 0;
      hideOverlay();
    }

    function updateScore(){
      document.getElementById('score').textContent = score;
      if(score > best){ best = score; localStorage.setItem('snakeBest', String(best)); document.getElementById('best').textContent = best; }
    }

    function spawnFood(){
      while(true){
        const x = Math.floor(Math.random()*COLS);
        const y = Math.floor(Math.random()*ROWS);
        if(!snake.some(s=>s.x===x && s.y===y)) { food = {x,y}; return; }
      }
    }

    // ===== 입력 처리 =====
    function setDirection(nx, ny){
      // 반대 방향 금지
      if (nx === -dir.x && ny === -dir.y) return;
      nextDir = {x:nx, y:ny};
      resumeIfPaused();
    }

    // 키보드
    const keymap = {
      ArrowUp: [0,-1], ArrowDown: [0,1], ArrowLeft: [-1,0], ArrowRight: [1,0],
      w:[0,-1], s:[0,1], a:[-1,0], d:[1,0]
    };
    document.addEventListener('keydown', (e)=>{
      const k = e.key in keymap ? e.key : e.key.toLowerCase();
      if(keymap[k]) { e.preventDefault(); const [x,y]=keymap[k]; setDirection(x,y); }
      if(e.key.toLowerCase()==='p') togglePause();
      if(e.key.toLowerCase()==='r') reset();
    }, {passive:false});

    // 터치 D-pad
    document.querySelectorAll('.btn-pad').forEach(b=>{
      b.addEventListener('click', ()=>{
        const d = b.dataset.dir;
        if(d==='up') setDirection(0,-1);
        if(d==='down') setDirection(0,1);
        if(d==='left') setDirection(-1,0);
        if(d==='right') setDirection(1,0);
      });
    });

    // 스와이프 제스처
    let tStart=null;
    canvas.addEventListener('touchstart', (e)=>{ if(e.touches.length===1){ tStart = {x:e.touches[0].clientX, y:e.touches[0].clientY, t:Date.now()}; } }, {passive:true});
    canvas.addEventListener('touchmove', (e)=>{ e.preventDefault(); }, {passive:false});
    canvas.addEventListener('touchend', (e)=>{
      if(!tStart) return;
      const tEnd = {x: (e.changedTouches[0]||{}).clientX, y: (e.changedTouches[0]||{}).clientY, t:Date.now()};
      const dx = (tEnd.x - tStart.x), dy = (tEnd.y - tStart.y);
      const adx = Math.abs(dx), ady = Math.abs(dy);
      const dt = tEnd.t - tStart.t;
      // 스와이프 임계치: 거리 24px 이상 & 10~500ms 사이
      if(dt<=600 && (adx>24 || ady>24)){
        if(adx > ady) setDirection(dx>0 ? 1 : -1, 0);
        else          setDirection(0, dy>0 ? 1 : -1);
      }
      tStart = null;
    }, {passive:true});

    // 버튼
    document.getElementById('restart').addEventListener('click', reset);
    document.getElementById('pause').addEventListener('click', togglePause);

    function togglePause(){
      running = !running;
      running ? hideOverlay() : showOverlay('Paused — tap any control to resume');
    }
    function resumeIfPaused(){ if(!running){ running = true; hideOverlay(); } }
    function showOverlay(text){
      const o = document.getElementById('overlay');
      o.querySelector('.bubble').textContent = text;
      o.hidden = false;
    }
    function hideOverlay(){ document.getElementById('overlay').hidden = true; }

    // ===== 게임 루프 =====
    function tick(ts){
      if(!lastTick) lastTick = ts;
      const elapsed = ts - lastTick;

      if (running && elapsed >= stepMs){
        lastTick = ts;
        step();
        draw();
      } else if (!running) {
        // 멈춘 상태에서도 프레임은 유지해 오버레이/리사이즈 반영
        draw();
      }
      requestAnimationFrame(tick);
    }

    function step(){
      // 방향 업데이트
      dir = nextDir;

      // 머리 새 위치
      const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };

      // 벽 충돌(끝에서 끝으로 워프 대신 벽에 부딪히면 패배)
      if (head.x < 0 || head.y < 0 || head.x >= COLS || head.y >= ROWS) {
        running = false;
        showOverlay('Game Over — press Restart');
        return;
      }

      // 자기 몸 충돌
      if (snake.some(s => s.x===head.x && s.y===head.y)) {
        running = false;
        showOverlay('Game Over — press Restart');
        return;
      }

      // 이동
      snake.unshift(head);

      // 먹이
      if (head.x === food.x && head.y === food.y){
        score += 1; updateScore(); spawnFood();
        // 속도 약간씩 빠르게 (모바일 고려, 너무 빠르지 않게 하한)
        stepMs = Math.max(70, stepMs - 2);
      } else {
        snake.pop();
      }
    }

    // ===== 렌더링 =====
    function drawGrid(){
      // 보드 배경
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--elev-2').trim() || '#f1f3f9';
      ctx.fillRect(0,0,W,H);

      // 안쪽 플레이필드
      const fieldRadius = 12;
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
      }
      roundRect(offX, offY, COLS*CELL, ROWS*CELL, fieldRadius, true, false);

      // 격자 (연한)
      ctx.strokeStyle = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'rgba(255,255,255,0.05)' : 'rgba(0,0,0,0.04)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      for(let x=1; x<COLS; x++){ ctx.moveTo(offX + x*CELL, offY); ctx.lineTo(offX + x*CELL, offY + ROWS*CELL); }
      for(let y=1; y<ROWS; y++){ ctx.moveTo(offX, offY + y*CELL); ctx.lineTo(offX + COLS*CELL, offY + ROWS*CELL); }
      ctx.stroke();
    }

    function draw(){
      // 전체 클리어
      ctx.clearRect(0,0,W,H);

      drawGrid();

      // 먹이
      ctx.fillStyle = '#ff6b6b';
      roundedCell(food.x, food.y, 8);

      // 뱀 몸통
      ctx.fillStyle = '#7C9CFF';
      for(let i=snake.length-1;i>=1;i--){
        roundedCell(snake[i].x, snake[i].y, 6);
      }
      // 뱀 머리 (강조/테두리)
      ctx.fillStyle = '#4c6fff';
      roundedCell(snake[0].x, snake[0].y, 6);
      ctx.strokeStyle = '#222';
      ctx.lineWidth = 2;
      strokeCell(snake[0].x, snake[0].y, 6);
    }

    function roundedCell(cx, cy, r){
      const x = offX + cx*CELL, y = offY + cy*CELL;
      roundRect(x+1, y+1, CELL-2, CELL-2, r, true, false);
    }
    function strokeCell(cx, cy, r){
      const x = offX + cx*CELL, y = offY + cy*CELL;
      roundRect(x+1, y+1, CELL-2, CELL-2, r, false, true);
    }
    function roundRect(x,y,w,h,r,fill,stroke){
      ctx.beginPath();
      ctx.moveTo(x+r, y);
      ctx.arcTo(x+w, y,   x+w, y+h, r);
      ctx.arcTo(x+w, y+h, x,   y+h, r);
      ctx.arcTo(x,   y+h, x,   y,   r);
      ctx.arcTo(x,   y,   x+w, y,   r);
      if(fill) ctx.fill();
      if(stroke) ctx.stroke();
    }

    // 시작
    reset();
    draw();
    requestAnimationFrame(tick);
  </script>
</body>
</html>
